#+TITLE: C/C++ Development Environment for Emacs

In this guide, I will help you to setup an efficient working C/C++
environment. Despite looking long, the setup is short and easy (mostly
copy/paste Emacs Lisp code into your =init.el=); most of the guide are
explanations and demonstrations of many useful features.

Please remember that there's a table of content on the top right
corner and you can use it to navigate this guide. If you feel your
internet connection is too slow for my guide, you can always clone and
read it offline: https://github.com/tuhdo/tuhdo.github.io

I added an Emacs repository that is properly configured for
demonstration purpose. You can clone and play with it and you can
ignore all the Elisp code for setting up throughout the guide:

#+begin_src sh
  git clone https://github.com/tuhdo/emacs-c-ide-demo.git ~/.emacs.d
#+end_src

Remember to backup your =~/.emacs.d= elsewhere. In the demo
repository, I already installed both =ggtags= and
=helm-gtags=. =helm-gtags= is enabled by default. If you want to use
=ggtags=, comment this line in =init.el=:

#+begin_src emacs-lisp
  (require 'setup-helm-gtags)
#+end_src

If you don't like to use Helm, also uncomment =(require 'setup-helm)=
and restart Emacs, because I made some global key bindings to some
commands that even if =helm-mode= is disabled, such commands still
uses Helm interface.

And uncomment this line:

#+begin_src emacs-lisp
  ;; (require 'setup-ggtags)
#+end_src

* Source code navigation
:PROPERTIES:
:ID:       2b850804-a33b-4f37-96fd-5bb4e422dbee
:END:
** Prerequisite:
:PROPERTIES:
:ID:       b1292347-d0ed-4421-9905-33f1050883b2
:END:
- Know how to use =package.el= and MELPA. If you don't know how to
  use, read the guide [[file:emacs-tutor3.org::*How%20to%20use%20Emacs%20package%20manager][How to use Emacs package manager]].

- Have [[http://www.gnu.org/software/global/][GNU Global]] installed. Download the source [[http://www.gnu.org/software/global/download.html][here]], or you can
  install it from the package manager of your OS (Linux distribution
  or Mac OS). For Windows users, download the [[http://adoxa.altervista.org/global/][Win32 port]].

- Install [[https://github.com/leoliu/ggtags][ggtags]]. After installing =ggtags= from MELPA, add this code
  snippet to setup =ggtags= and key bindings:

#+begin_src emacs-lisp
  (require 'ggtags)
  (add-hook 'c-mode-common-hook
            (lambda ()
              (when (derived-mode-p 'c-mode 'c++-mode 'java-mode 'asm-mode)
                (ggtags-mode 1))))

  (define-key ggtags-mode-map (kbd "C-c g s") 'ggtags-find-other-symbol)
  (define-key ggtags-mode-map (kbd "C-c g h") 'ggtags-view-tag-history)
  (define-key ggtags-mode-map (kbd "C-c g r") 'ggtags-find-reference)
  (define-key ggtags-mode-map (kbd "C-c g f") 'ggtags-find-file)
  (define-key ggtags-mode-map (kbd "C-c g c") 'ggtags-create-tags)
  (define-key ggtags-mode-map (kbd "C-c g u") 'ggtags-update-tags)

  (define-key ggtags-mode-map (kbd "M-,") 'pop-tag-mark)
#+end_src

- Or, [[https://github.com/emacs-helm/helm][helm]] + [[https://github.com/syohex/emacs-helm-gtags][helm-gtags]]. Helm is awesome and if you are going to use
  Helm, please read the [[http://tuhdo.github.io/helm-intro.html][Helm guide]]. Remember to setup =Helm= before
  using =helm-gtags=. You can use this [[https://github.com/tuhdo/emacs-c-ide-demo/blob/master/custom/setup-helm.el][sample configuration]]. When
  includes the above file in your =~/.emacs.d=, remember to add
  =(require 'setup-helm)= to your =init.el=.

#+begin_src emacs-lisp
  ;; this variables must be set before load helm-gtags
  ;; you can change to any prefix key of your choice
  (setq helm-gtags-prefix-key "\C-cg")

  (require 'helm-gtags)

  (setq
   helm-gtags-ignore-case t
   helm-gtags-auto-update t
   helm-gtags-use-input-at-cursor t
   helm-gtags-pulse-at-cursor t

   helm-gtags-suggested-key-mapping t
   )

  ;; Enable helm-gtags-mode in Dired so you can jump to any tag
  ;; when navigate project tree with Dired
  (add-hook 'dired-mode-hook 'helm-gtags-mode)

  ;; Enable helm-gtags-mode in Eshell for the same reason as above
  (add-hook 'eshell-mode-hook 'helm-gtags-mode)

  ;; Enable helm-gtags-mode in languages that GNU Global supports
  (add-hook 'c-mode-hook 'helm-gtags-mode)
  (add-hook 'c++-mode-hook 'helm-gtags-mode)
  (add-hook 'java-mode-hook 'helm-gtags-mode)
  (add-hook 'asm-mode-hook 'helm-gtags-mode)

  ;; key bindings
  (define-key helm-gtags-mode-map (kbd "M-s") 'helm-gtags-select)
  (define-key helm-gtags-mode-map (kbd "M-.") 'helm-gtags-dwim)
  (define-key helm-gtags-mode-map (kbd "M-,") 'helm-gtags-pop-stack)
  (define-key helm-gtags-mode-map (kbd "C-c <") 'helm-gtags-previous-history)
  (define-key helm-gtags-mode-map (kbd "C-c >") 'helm-gtags-next-history)
#+end_src

Before using the =ggtags= or =helm-gtags=, remember to create a GTAGS
database by running =gtags= at your project root in terminal:

#+begin_src shell-script
  $ cd /path/to/project/root
  $ gtags
#+end_src

After this, a few files are created:

#+begin_src shell-script
  $ ls G*
  GPATH   GRTAGS  GTAGS
#+end_src

- *GTAGS*: definition database
- *GRTAGS*: reference database
- *GPATH*: path name database
 
If you use =ggtags=, you have a command for creating GTAGS database,
that is =ggtags-create-tags=; this is recommended way when using
=ggtags=, to let it know where the project root is.

** Basic movements
:PROPERTIES:
:ID:       45f1bb42-08e5-43b9-8ea9-7b5e1124f89e
:END:
- *C-M-f* runs =forward-sexp=, move forward over a balanced
  expression that can be a pair or a symbol. Demo:

  [[file:static/c-ide/forward-func.gif][file:static/c-ide/forward-func.gif]]

- *C-M-b* runs =backward-sexp=, move backward over a balanced
  expression that can be a pair or a symbol. Demo:

  [[file:static/c-ide/backward-func.gif][file:static/c-ide/backward-func.gif]]

- *C-M-k* runs =kill-sexp=, kill balanced expression
  forward that can be a pair or a symbol. Demo:

  [[file:static/c-ide/kill-func-body.gif][file:static/c-ide/kill-func-body.gif]]

- *C-M-<SPC>* or *C-M-@* rusn =mark-sexp=, put mark after
  following expression that can be a pair or a symbol. Demo:

  [[file:static/c-ide/mark-func-body.gif][file:static/c-ide/mark-func-body.gif]]

- *C-M-a* runs =beginning-of-defun=, which moves point to beginning of
  a function. Demo:

  [[file:static/c-ide/beginning-of-defun.gif][file:static/c-ide/beginning-of-defun.gif]]

- *C-M-e* runs =end-of-defun=, which moves point to end of a
  function. Demo:

  [[file:static/c-ide/end-of-defun.gif][file:static/c-ide/end-of-defun.gif]]

- *C-M-h* runs =mark-defun=, which put a region around whole current
  or following function. Demo:

  [[file:static/c-ide/mark-defun.gif][file:static/c-ide/mark-defun.gif]]
** Basic concepts of tag
:PROPERTIES:
:ID:       b4902a85-f303-4f5f-8c13-1eb3d2d2de73
:END:
A tag is a name of an entity in source code. An entity can be a
variable, a method definition, an include-operator... A tag contains
several information such as name of the tag (the name of the variable,
class, method), location of this tag in source code and which file it
belongs to. As an example, GNU Global generates three tag databases:

- *GTAGS*: definition database
- *GRTAGS*: reference database
- *GPATH*: path name database

A definition of a tag is where a tag is implemented. For example, a
function definition is the body where it is actually implemented, or a
variable definition is where the type and its property (i.e static) is
specified.

A reference of a tag is where a tag is used in a source tree, but not
where it is defined.

** Find definitions in current buffer
:PROPERTIES:
:ID:       3a64c7a4-e8a5-42b9-9476-28dff9e5cb96
:END:
The Imenu facility offers a way to find the major definitions, such as
function definitions, variable definitions in a file by name. =ggtags=
can integrate Imenu:

#+begin_src emacs-lisp
  (setq-local imenu-create-index-function #'ggtags-build-imenu-index)
#+end_src

If you use Helm, use [[http://tuhdo.github.io/helm-intro.html#sec-7][helm-semantic-or-imenu]]. You can use it as an
outline tree like in other IDEs. Here is a demo:

[[file:static/part3/helm-semantic-or-imenu.gif][file:static/part3/helm-semantic-or-imenu.gif]]

** Find definitions in project
:PROPERTIES:
:ID:       0331265b-7c3f-457e-ba1d-ef6c3cd24208
:END:
- Using =gtags=: by default, =M-.= runs =ggtags-find-tag-dwim= when
  =ggtags-mode= is enabled. The command =ggtags-find-tag-dwim= jump to
  tag base on context:

  - If the tag at point is a definition, =ggtags= jumps to a
    reference. If there is more than one reference, it displays a list
    of references.

  - If the tag at point is a reference, =ggtags= jumps to tag
    definition.

  - If the tag at point is an include header, it jumps to that header.

You can jump back to original location where you invoked
=ggtags-find-tag-dwim= by =M-,=, which runs =pop-tag-mark= (if you
follow my key bindings).

You can also find arbitrary tag definition when invoking =M-.= on
blank space. A prompt asks you for tag pattern, which is a regexp.

If =ggtags= gives you a list of candidates, you can use =M-n= to move
to next candidate and =M-p= to move back previous candidate. Use =M-g
s= to invoke Isearch on candidate buffer list.

#+BEGIN_CENTER
[[file:static/c-ide/ggtags-definitions.png][file:static/c-ide/ggtags-definitions.png]]

(screenshot taken from [[https://github.com/leoliu/ggtags][ggtags]])
#+END_CENTER

- Using =helm-gtags=: If key bindings are properly setup as above,
  =M-.= runs =helm-gtags-dwim=, which behaves the same as
  =ggtags-find-tag-dwim=. Similarly, you jump back to original
  location by using =M-,=, which runs =tags-loop-continue= (Emacs
  default).

#+BEGIN_CENTER
[[file:static/c-ide/helm-gtags-definitions.png][file:static/c-ide/helm-gtags-definitions.png]]

(screenshot taken from [[https://github.com/syohex/emacs-helm-gtags][helm-gtags]])
#+END_CENTER

You can also find arbitrary tag definition when invoking =M-.= on
blank space. A prompt asks you for tag pattern, which is a
regexp. =helm-gtags= provides a really nice feature that uses Helm to
display all tags in a project and incrementally filtering, and is
really fast:

[[file:static/c-ide/helm-gtags-select.gif][file:static/c-ide/helm-gtags-select.gif]]

** Find references in project
:PROPERTIES:
:ID:       410cfad4-a08d-4139-8c37-cb1bff5bd44e
:END:
- Using =ggtags=:  Either run =ggtags-find-tag-dwim= or
  =ggtags-find-reference=, which only finds references.

- Using =helm-gtags=: Either run =helm-gtags-dwim= or
  =helm-gtags-find-rtag=, which only finds references.

** Find files in project
:PROPERTIES:
:ID:       b6c7d5a9-2fce-4488-a7d5-3eb301b6b89a
:END:
- Using =ggtags=: Run =ggtags-find-file= to find a file from all the
  files indexed. If point is on an included header file,
  =ggtags-find-tag-dwim= automatically jumps to the file.

- Using =helm-gtags=: Run =helm-gtags-find-files= to find files
  matching regexp. If point is on an included header file,
  =helm-gtags-dwim= automatically jumps to the file.

** View visited tags with tag stack
:PROPERTIES:
:ID:       db6bf87e-969d-42b8-ae60-b0b58f13e073
:END:
- Using =ggtags=: As you know that you can jump back with
  =pop-tag-mark= (bound to =M-,=), you can also view a list of visited
  tags using =ggtags-view-tag-history=, which is bound to =C-c g
  h=. It displays visited tags from newest to oldest, that is from top
  to bottom.

- Using =helm-gtags=: Similarly, =helm-gtags= also has the command
  =helm-gtags-show-stack= that shows visited tags from newest to
  oldest, from top to bottom.
* General completion with =company-mode=
:PROPERTIES:
:ID:       26a77004-9171-4b04-bea7-28a6089de586
:END:
=company-mode= is a text completion framework for Emacs. The name
stands for "complete anything". It uses pluggable back-ends and
front-ends to retrieve and display completion candidates.

It comes with several back-ends such as Elisp, Clang, Semantic, Eclim,
Ropemacs, Ispell, CMake, BBDB, Ya snippet, dabbrev, etags, gtags,
files, keywords and a few others.

After installing =company-mode= from MELPA, activate it globally:

#+begin_src emacs-lisp
  (require 'company)
  (add-hook 'after-init-hook 'global-company-mode)
#+end_src

*General Usage*: Completion will start automatically after you type a
few letters. Use *M-n* and *M-p* to select, *<return>* to complete or
*<tab>* to complete the common part. Search through the completions
with *C-s*, *C-r* and *C-o*. Press *M-(digit)* to quickly complete
with one of the first 10 candidates. When the completion candidates
are shown, press *<f1>* to display the documentation for the selected
candidate, or *C-w* to see its source. Not all back-ends support
this.

The variable =company-backends= specifies a list of backends that
=company-mode= uses to retrieves completion candidates for you.

That's the basic. In the later sections, you will configure
=company-mode= to provide completion candidates.
* Demo projec
:PROPERTIES:
:ID:       4b22b03c-0bd2-4773-9a04-571e7f0ed648
:END:
I uploaded a sample project for you to play with: [add later]. It has
this directory structure:

#+begin_src fundamental
  project_root/
              Makefile
              src/
                  feature1/
              include1/
                  feature1/
              include2/
#+end_src

The following files are in =src/= directory: =lib1.c=, =lib2.c=,
=lib1.h=, =lib2.h=, =feature1.h=, =feature1.c= and =main.c=. For the
=.h= files, it has this template:

#+begin_src c
  void filename_func1();
  int filename_func2(int a, int b);
#+end_src

=filename= or =FILENAME= is actual filename like =lib1=.

For =.c= files, except for =main.c=, create them according to this
template:

#+begin_src c
  #include "filename.h"

  void filename_func1() { }

  int filename_func2(int a, int b) { }
#+end_src

* OPTION 1: Source code completion using Clang
:PROPERTIES:
:ID:       b0c73319-7e93-4a43-a191-46cddf1ec187
:END:
Emacs has a package named [[https://github.com/Sarcasm/irony-mode][irony-mode]]. =irony-mode= includes a server
that provides the libclang interface.

Prerequisite:

- CMake >= 2.8.3
- libclang

If you don't have those dependencies, install it to your system. Then
install =irony-mode= from MELPA, as you did with =company-mode=. You
should also install =company-irony= as well.

After that, =M-x irony-install-server= to compile the =irony-server=
written in C++ and comes with the installation of =irony-mode=. Wait
until the =irony-mode= finishes compiling.

Setup:

#+begin_src emacs-lisp
  (add-hook 'c++-mode-hook 'irony-mode)
  (add-hook 'c-mode-hook 'irony-mode)
  (add-hook 'objc-mode-hook 'irony-mode)

  (add-to-list 'company-backends 'company-irony)
  (define-key c-mode-map  [(tab)] 'company-irony)
  (define-key c++-mode-map  [(tab)] 'company-irony)
#+end_src

In the above configuration, you add =company-irony= to a list of
=company-backends=, so the next time you execute the generic
completion command =company-complete=, it will use =company-irony=
backend for complete. =company-backends=, as its name suggested,
contains many different backends. The backend that got added later
will have higher precedence. If a backend fails, =company-complete=
uses the next backend until all backends are tried. You can view a
list of backend by *C-h v*, then enter =company-backends=.

To provide completion for your project, you have to tell where your
include paths are. Create a file =.clang_complete= at your project
root containing the compilation flags, one per line. An example of
=.clang_complete= file:

#+begin_src fundamental
  -I./include
  -I/usr/include
#+end_src

In the above example, =-I./include= specifies the include paths relative
to your project. =-I/usr/include= specifies your system header files
at =/usr/include=. After that, run the command =irony-cdb-menu=. It
will ask which compilation database to choose. Since you use
=.clang_complete=, press *l*, which loads =.clang_complete=. After
that, you can use =company-complete= that includes =company-irony=
backend to complete your code.

*_Exercise_*:

Now it's time to use the demo project. Let's test auto-completion by
including appropriate header file. Everything should work fine when
all files are under the same directory. Let's split the files into
different directories we created before, like this:

#+begin_src fundamental
  project_root/
              Makefile
              src/
                  main.c
                  lib.c
                  lib2.c
                  feature1/
                      feature1.c
              include1/
                  lib.h
                  feature1/
                      feature1.h
              include2/
                  lib2.h
#+end_src

[[file:static/c-ide/ede-rearrange-project-dir.gif][file:static/c-ide/ede-rearrange-project-dir.gif]]

Now, =company-irony= won't see anything related to your project
anymore. To fix this, at the file =.clang_complete= under your
=project_root= with the following content:

#+begin_src fundamental
  -I./include1
  -I./include2p
#+end_src

That's it! Now, run =irony-cdb-menu= and press *l* to load the new
=.clang_complete= file. Everything should work now.

** Command: =company-gtags=
:PROPERTIES:
:ID:       fd219ce1-3d64-42ec-8050-70a2c0ecbf23
:END:
This command uses GTAGS database from =GNU Global= to retrieve
completion candidates. It displays ALL completion candidates in GTAGS
database regarding of scope. Use =company-gtags= to provide code
completion in your current project.
** *Package*: =company-c-headers=
:PROPERTIES:
:ID:       6e05e8a5-04a3-4279-bf99-22fd627c0e92
:END:
[[https://github.com/randomphrase/company-c-headers][company-c-headers]] provides auto-completion for C/C++ headers using
Company. After installing from MELPA, set it up:

#+begin_src emacs-lisp
  (add-to-list 'company-backends 'company-c-headers)
#+end_src

[[file:static/c-ide/company-c-header.png][file:static/c-ide/company-c-header.png]]

* OPTION 2: Source code completion using CEDET
:PROPERTIES:
:ID:       419c04f5-95b6-4457-83fe-9288361e7bcf
:END:
** What is CEDET?
:PROPERTIES:
:ID:       5e06a903-4853-4093-a5b0-b5b28b3a6eaa
:END:
CEDET is a (C)ollection of (E)macs (D)evelopment (E)nvironment (T)ools written
with the end goal of creating an advanced development environment in
Emacs. CEDET includes common features such as intelligent completion,
source code navigation, project management, code generation with
templates . CEDET also provides a framework for working with
programming languages; support for new programming languages can be
added and use CEDET to provide IDE-like features.

This tutorial only helps you use CEDET to get completion feature for
C/C++. Finally, why is this part option? CEDET has a limitation that
people don't like: Syntax analyzing takes time. Many people don't
understand this process and assume that CEDET is slow. It is not that
the fault of CEDET. Because real parsing takes time and such a task,
while possible using Emacs Lisp, but is too much for current Emacs
implementation. CEDET does some nice optimizations to speed it up as
fast as it can: idle parsing, caching and incremental parsing to
reduce computational time. Consider a project called [[https://github.com/drothlis/clang-ctags#performance][clang-ctags]] using
Clang to generate tag database: 

#+BEGIN_QUOTE
"Running clang-ctags over a much larger input, such as the entire llvm
C/C++ sources (7k files, 1.8 million lines of code) took 98 minutes
and a peak memory usage of 140MB."
#+END_QUOTE

The more accurate to analyze the source code, the more time the parser
needs to spend. *If you don't like to wait, skip this section and use
=company-clang= instead*. At least you will have completion with
system header files, but not your project.

** Why use CEDET?
:PROPERTIES:
:ID:       b8922b61-b52a-4690-8626-4ca463dd2f85
:END:
CEDET is simple to setup and portable (right winthin Emacs and written
entirely with Emacs Lisp). Without CEDET, you have to use external
tools and third party Emacs packages. The downside of external tools
is that they are not specifically designed for Emacs. They have
similar use cases, but not always satisfying. For example, source code
indexing tools such as GNU Global and Exuberant Ctags are really good
at working static source code, but they do not keep track changes in
real time; CEDET does:

[[file:static/auto_complete.gif][file:static/auto_complete.gif]]

As you can see, CEDET recognizes when =printk.h= is included and
provides appropriate completion candidates. In contrast, non-context
sentisve completion is like this:

[[file:static/c-ide/company-clang-company-gtags.gif][file:static/c-ide/company-clang-company-gtags.gif]]

In this case, the completion system gets all candidates straight from
GNU Global generated database without considering current context.

The disadvantage is that CEDET is written in Emacs Lisp, and it is
bound to the performance limitations of Emacs. Even though, CEDET is
still really fast for moderate-size source files. CEDET also makes use
of external tools like GNU Global or Cscope or Exuberant Ctags for
finding symbol references/definition in a project to reduce its
workload.

** Installation
:PROPERTIES:
:ID:       d6418a70-0ef0-4e53-895f-cc5f85339392
:END:
CEDET was merged into Emacs since 23.2. You do not need to install
CEDET manually. However, you can also use the development repository
that contains latest bug fixes and more features. Nevertheless, the
built-in Emacs is still adequate for daily usage and convenient for
trying out before actually cloning and use the development
version. Skip this section if you only want to try Emacs. Come back
later if you really like it.

If you really want to use the development version with latest feature,
checkout this branch:

#+begin_src sh
  bzr checkout bzr://cedet.bzr.sourceforge.net/bzrroot/cedet/code/trunk cedet
#+end_src

Be sure to place the checked out =cedet= directory in your
=~/.emacs.d=. Then compile it:

#+begin_src sh
  cd cedet
  make # wait for it to complete
  cd contrib
  make
#+end_src

Finally, assume that you placed your newly cloned CEDET in
=~/.emacs.d=, load it into your Emacs:

#+begin_src emacs-lisp
  (load-file (concat user-emacs-directory "/cedet/cedet-devel-load.el"))
  (load-file (concat user-emacs-directory "cedet/contrib/cedet-contrib-load.el"))
#+end_src

** Semantic minor modes
:PROPERTIES:
:ID:       e57ff2d7-623a-4feb-91ac-c69487996527
:END:
=Semantic= is a package that provides language-aware editing commands
based on source code parsers. Parsing is a process of analyzing source
code based on programming language syntax. Emacs understands your
source code through this process to provides features such as
contextual code completion, code navigation. Here is an example how
Semantic helps you provides completion for Boost:

[[file:static/c-ide/semantic-boost-demo.gif][file:static/c-ide/semantic-boost-demo.gif]]

**** *Setup Semantic*
:PROPERTIES:
:ID:       22bc4bb9-df93-4702-8b7d-9eb8b038059b
:END:
To enable code completion using Semantic, add the following code:

#+begin_src emacs-lisp
  (require 'cc-mode)
  (require 'semantic)

  (global-semanticdb-minor-mode 1)
  (global-semantic-idle-scheduler-mode 1)

  (semantic-mode 1)
#+end_src

**** *Command*: =semantic-mode=
:PROPERTIES:
:ID:       8f24eec1-81f5-445b-bdc7-1b7e27943ce5
:END:
This command activates =semantic-mode=. In Semantic mode, Emacs parses
the buffers you visit for their semantic content. The parsing looks
like this:

[[file:static/c-ide/semantic-parsing.gif][file:static/c-ide/semantic-parsing.gif]]

Notice that at the bottom, Emacs prints messages like this: =Parsing
<file> (LL)...<progress in percentage>=. This is common behavior of
=Semantic=: when you perform a jump to a symbol or perform a
completion, =Semantic= tries to be accurate by parsing all the
included files and all the included files in the included files and so
on, until it reaches the end:

You may worry that this process takes a long time. Sometimes, it
does. However, this is just a one time process. Once it is parsed,
Semantic will cache the parsing result for future use. The next time
you perform some action on the parsed code, such as code completion,
you will get your desired output instantly.

**** *Command*: =global-semanticdb-minor-mode=
:PROPERTIES:
:ID:       668b4f56-2977-4783-b7cb-b5d84a0dd769
:END:
As mentioned above, Semantic caches parsing result for future
use. To do that, =semanticdb-minor-mode= must be activated. In
Semantic DB mode, Semantic parsers store results in a database, which
can be saved for future Emacs sessions. The cache is saved in
directory specified by =semanticdb-default-save-directory=
variable. The default directory is =~/.emacs.d/semanticdb=.

**** *Command*: =global-semantic-idle-scheduler-mode=
:PROPERTIES:
:ID:       fb0dd2f4-78c0-4e9c-b9d7-0ec4caa3fde3
:END:
When =semantic-idle-scheduler-mode= is enabled, Emacs periodically
checks to see if the buffer is out of date, and reparses while the
user is idle (not typing). When this mode is off, a buffer is only
reparsed when user explicitly issue some command.

With =semantic-idle-scheduler-mode=, Emacs keeps track live changes of
your source code.
**** *Add more system include paths*
:PROPERTIES:
:ID:       5bd738d7-ccc7-412a-8414-45d7cc9e41aa
:END:
By default, Semantic automatically includes some default system
include paths such as =/usr/include=, =/usr/local/include=... You can
view the list of include paths in
=semantic-dependency-system-include-path=. To add more include paths,
for example Boost include paths, use the function
=semantic-add-system-include= like this:

#+begin_src emacs-lisp
  (semantic-add-system-include "/usr/include/boost" 'c++-mode)
  (semantic-add-system-include "~/linux/kernel")
  (semantic-add-system-include "~/linux/include")
#+end_src

If you want the system include paths to be available on both C/C++
modes, then ignore the optional mode argument in
=semantic-add-system-include=.
**** Completion using =company-mode=
:PROPERTIES:
:ID:       05364ae1-6c0c-48b9-8759-823e70d9f320
:END:
=companh-mode= provides a command called =company-semantic= that uses
SemanticDB to retrieve completion candidates. Function interface of
each candidate is shown in the minibuffer. One nice thing of
=company-semantic= is that it fixed an issue of original Semantic
completion =semantic-ia-complete-symbol=: it can show you completions
even if there's no prefix. The original =semantic-ia-complete-symbol=
requires to have at least one character as a prefix for finding
completions.

**** *Package*: =function-args=
:PROPERTIES:
:ID:       3e24664a-c6cc-44d5-b0ea-457a25590d38
:END:
[[https://github.com/abo-abo/function-args][function-args]] is a GNU Emacs package for showing an inline
arguments hint for the C/C++ function at point.

Setup:

#+begin_src emacs-lisp
  (require 'function-args)
  (fa-config-default)
  (define-key c-mode-map  [(contrl tab)] 'moo-complete)
  (define-key c++-mode-map  [(control tab)] 'moo-complete)
#+end_src

Basic Usage (taken from =function-args= homepage):

- =fa-show=: Show an overlay hint with current function arguments like
  so:

  [[file:static/c-ide/fa-show][file:static/c-ide/fa-show]]

  The point position is tracked and the current hint argument is
  updated accordingly. After you've called it with =M-i=, you can cycle
  the overloaded functions with =M-n/M-h=. You can dismiss the hint with
  =M-u= or by editing anywhere outside the function arguments.

- =fa-jump=: While the overlay hint from =fa-show= is active, jump to
  the current function. The default shortcut is =M-j=. If the overlay
  isn't active, call whatever was bound to =M-j= before (usually it's
  =c-indent-new-comment-line=).

- =moo-complete= (must install =helm=): It's essentially a
  c++-specific version of semantic-ia-complete-symbol. It behaves
  better, because it accounts more for function overloading and
  inheritance. Also it's prettier (type parts are fontified) and
  faster (helm is used for completion). You can invoke it with =M-o=
  by default.

  [[file:static/c-ide/moo-complete.png][file:static/c-ide/moo-complete.png]]

There are a few more commands. You can view all the descriptions for
all commands [[https://github.com/abo-abo/function-args#main-functions][here]].

** CEDET can do more
:PROPERTIES:
:ID:       a4605a59-5c3f-4604-84ce-6f22f15ea8bc
:END:
This guide only covers a portion of CEDET. Since Semantic parses
source code and creates a database for code  completion, it would be
useful to reuse the database for other features such as code
navigation, jump to definition and gather references. These are cool
features. For example, CEDET provide nice syntax highlighting for
gathering references:

[[file:static/c-ide/semantic-symref.gif][file:static/c-ide/semantic-symref.gif]]

The above feature is called Semantic Symref. It queries tag references
from SemanticDB and display the result in another buffer. Please
refer to [[https://www.gnu.org/software/emacs/manual/html_node/semantic/SymRef.html][GNU Manual - Symbol References]] for more info. If your project
is only the size of Emacs or similar, then Semantic Symref is a viable
choice. Remember that when entering new files, Semantic takes time to
parse and if you gather references for the first time, you will have
to wait for a while for Semantic doing its job. After the first time,
subsequent uses of Semantic Symref happens instantly.

But, for navigating around the source tree, we already have =ggtags=
and =helm-gtags=, which uses GNU Global for much faster indexing for
large project like Linux kernel. The only thing that other tools
cannot do, is context-sensitive completion. That's why we only use
CEDET for code completion in this guide. Nevertheless, Semantic Symref
is still a viable choice for small to medium sized projects. Choose
the one you prefer.

Other solutions that use =clang= is quite good but not there yet. For
example, [[https://github.com/brianjcj/auto-complete-clang][auto-complete-clang]] is fine for getting system header
candidates (since =clang= has system paths by default), but it has no
concept of project and is not aware of project include path. You can
add more arbitrary include paths to [[https://github.com/brianjcj/auto-complete-clang][auto-complete-clang]], but it won't
be pretty: once you add an include path for a project, it is visible
to all other projects since the include path is treat as system
include path. That means, whenever you try to complete something, you
get irrelevant candidates from other projects as well. Quite
annoying. =company-clang= also has the same problem. Another solution
is [[https://github.com/Andersbakken/rtags][rtags]], but it is really complicated to setup, especially if you use
=make=; I never succeed with it. =clang= based packages still have a
long way to go. CEDET also supports =clang= for retrieving completion
candidates. It also has the limitations of other packages.

CEDET is best used with new project, because Semantic parse code as
you write. As a result, you won't have to wait for parsing unknown
source files to get completion candidates.

** Project management with EDE
:PROPERTIES:
:ID:       d837c3b1-b5ca-4871-9b7b-cf5d24b2f8dd
:END:
EDE, short for Emacs Development Environment, is a generic interface
for managing projects. In EDE, a project hierarchy matches a directory
hierarchy. The project's topmost directory is called the project root,
and its subdirectories are sub-projects.

EDE can do many things but we will just use it for code completion at
project level. To demonstrate the use of EDE, we will create a little
project of our own.

To setup EDE:

#+begin_src emacs-lisp
  (require 'ede)
  (global-ede-mode)
#+end_src

*_Exercise_*:

Now, let's try completion =main.c=. Nothing also happens as in the
case of =company-irony=. It is because Semantic only looks for header
files in current directory by default. If you put it elsewhere, you
have to tell Semantic where it is. This is not limited to only
Semantic; you have to specify project include path in Eclipse as well.

- Create a new file called =cedet-projects.el= in =~/.emacs.d/=.
- In this file, add a new =ede-cpp-root-project= in this form:

#+begin_src emacs-lisp
  (ede-cpp-root-project "project_root"
                        :file "/dir/to/project_root/Makefile")
#+end_src

The first argument to =ede-cpp-root-project= is project name. =:file=
argument specifies path to project root. You must create a file in the
project root, since EDE uses that file as an "anchor" to project
root; in our case, =Makefile= is the anchor file. Not sure why EDE
just straightly uses root directory.

- Add include directories specific to the project and in your system:

#+begin_src emacs-lisp
  (ede-cpp-root-project "project_root"
                        :file "/dir/to/project_root/Makefile"
                        :include-path '("/include1"
                                        "/include2") ;; add more include
                        ;; paths here
                        :system-include-path '("~/linux"))
#+end_src

=:include-path= specifies directories local to your projects that EDE
should search first when looking for a header file. =:incluide-path=
is relative to project root specified in =:file=.

=:system-include-path= specifies system include paths that do not
belong to current project. Note that despite it is called
=system-include-path=, it does not have to be in place like
=/usr/include=. You can specify any include directories outside of
your current project as "system headers".

After done setting up your project, save the file and execute that
=ede-cpp-root-project= expression with *C-x C-e*. Now, Semantic is
aware of your project include paths. However, you have to do one last
thing: either close the file =main.c= and reopen it or =M-x
semantic-force-refresh= to tell Semantic to analyze =main.c=
again. Otherwise, Semantic will still keep the previous parsing result
of this file and completion candidates won't be available. As a
result, it is important to load EDE projects defined by
=ede-cpp-root-project= before opening any project file.

After that, try auto-completion and you will see everything is working
fine again:

[[file:static/c-ide/ede-project.gif][file:static/c-ide/ede-project.gif]]

Summary:

- EDE, short for Emacs Development Environment, is a generic interface
  for managing projects.
- EDE enables Semantic to find sources and perform project level
  completions.
- To add a C/C++ project, simply create a project definition with this
  template in a file, such as =ede-projects.el=:

#+begin_src emacs-lisp
  (ede-cpp-root-project "project_root"
                        :file "/dir/to/project_root/Makefile"
                        :include-path '("/include1"
                                        "/include2") ;; add more include
                        ;; paths here
                        :system-include-path '("~/linux"))
#+end_src

- Load =ede-projects.el= when Emacs start.
- If you have opening files, either close or refresh it with =M-x
  semantic-force-refresh= to make Semantic aware of new changes.

** Source code navigation using Senator
:PROPERTIES:
:ID:       56164139-be1c-41bd-9e1d-f55335341d80
:END:
 Senator is a part of CEDET. Senator stands for SEmantic
 NAvigaTOR. Senator provides some useful commands for operating on
 semantic tags in SemanticDB. As you can see, another utility makes
 use of SemanticDB, aside from smart completion. It is like the heart
 of CEDET: once Semantic fails to parse, tools centered around it fail
 as well. If such situation happens, you always have a reserved and
 simpler solution: use GNU Global with =ggtags= or =helm-gtags=
 frontends. The following commands are provided by Senator:

*** Navigation
:PROPERTIES:
:ID:       09424bff-048a-41b1-91d5-6b0f692f8c05
:END:

Senator provides commands for navigating by tag.

- *C-c , n* runs =senator-next-tag=, navigate to the next Semantic
  tag.

- *C-c , p* runs =senator-previous-tag=, navigate to the previous
  Semantic tag.

  Here is how both of those commands work:

  [[file:static/c-ide/senator-next-previous-tag.gif][file:static/c-ide/senator-next-previous-tag.gif]]

  As you see,the C macro (in the screenshot, its =DECLARE_COMPLETION=)
  is not considered a tag.

- =senator-jump= (only available in CEDET bzr), specify a tag to jump
  to. *TAB* for a list of available Semantic tags in current buffer,
  similar to *TAB* in *M-x* in stock Emacs. If you use Helm, use
  =helm-semantic-or-imenu= instead.

  Demo (=helm-mode= is disabled):

  [[file:static/c-ide/senator-jump.gif][file:static/c-ide/senator-jump.gif]]

- *C-c , u* runs =senator-go-to-up-reference=, move up one reference
  level from current tag. An upper reference level of a tag is the
  source that defines the tag or includes the tag. This is incredibly
  useful when you want to jump from a function declaration in a class
  to its definition, or jump to the class that a function belongs to,
  quickly.

  [[file:static/c-ide/senator-go-to-up-reference.gif][file:static/c-ide/senator-go-to-up-reference.gif]]

  In the demo, I only use =senator-go-to-up-reference= to switch from
  a declaration, that is =PIC32F42(string Name, short MemorySize);= in
  =PIC32F42.h= to its implementation in =PIC32F42.c=. *C-c , u* again,
  point jump is on the class =PIC32F42=, which is the class that the
  function belongs. Class =PIC32F42= has its parent class
  =Microcontrller=, and I run *C-c , u* again to move point to
  =Microcontrller= class. At this point, I cannot move further.

Semantic also provides a useful command for finding all references of
a tag, that is =semantic-symref=, as demonstrated in previous
section. On a symbol, *C-c , g* and a prompt appear asking for a tag
for gathering references, with the default is the symbol at
point. Leave prompt blank and *RET* to use the default or enter
another symbol if you change your mind.
*** Copy/Paste
:PROPERTIES:
:ID:       a7861142-010c-4640-9ec7-d201dc918f92
:END:

- =C-c , M-w= runs =senator-copy-tag=, take the current tag, and place
  it in the tag ring.

- =C-c , C-w= runs =senator-kill-tag=, take the current tag, place it
  in the tag ring, and kill it. Killing the tag removes the text for
  that tag, and places it into the kill ring. Retrieve that text with
  *C-y*.

  The above commands are basically like normal =M-w= and =C-w=, but are
  used for tags. For example, run =C-c , C-w= with point inside a
  function definition kills the whole function body and its
  interface, or you can kill function parameters, and can be yanked
  back with *C-y*:

  [[file:static/c-ide/senator-kill-yank-tag.gif][file:static/c-ide/senator-kill-yank-tag.gif]]

  As you see, the function body and its interface is killed and yanked
  back with *C-y*. You can also see that the function parameter, aside
  from its name, its type is also removed when the command is executed.

- =C-c , C-y= runs =senator-yank-tag=, yank a tag from the tag
  ring. The form the tag takes is different depending on where it is
  being yanked to. For example, in previous example with =C-c , C-w=,
  when you run *C-y*, it yanks the whole thing including function
  interface and its body. *C-c , C-y* only yanks the function
  interface.

  [[file:static/c-ide/senator-yank-tag.gif][file:static/c-ide/senator-yank-tag.gif]]

- =C-c , r= runs =senator-copy-tag-to-register=, copy the current tag
  into a register. With prefix argument will delete the text of the
  tag to the kill ring.

*** Obsolete commands
:PROPERTIES:
:ID:       0545cf56-b2bc-4efa-80aa-eca9911bf32b
:END:
Senator also provides commands for code completion:
=senator-complete-symbol= and =senator-completion-menu-popup=. Code
completion provided by Senator is simpler than the actual completion
provided by =semantic-ia-complete-symbol= command that is used by
=moo-complete= for a list of candidates with full information, such as
complete function interface is displayed correctly. These two
completion commands are provided.

** *Package*: =company-c-headers=
:PROPERTIES:
:ID:       6e05e8a5-04a3-4279-bf99-22fd627c0e92
:END:
[[https://github.com/randomphrase/company-c-headers][company-c-headers]] provides auto-completion for C/C++ headers using
Company. After installing from MELPA, set it up:

#+begin_src emacs-lisp
  (add-to-list 'company-backends 'company-c-headers)
#+end_src

[[file:static/c-ide/company-c-header.png][file:static/c-ide/company-c-header.png]]

* Project management with Projectile
:PROPERTIES:
:ID:       c5b93bb9-1b91-4c94-aa55-9a86976ccf88
:END:
You may ask, why another project management tool? The differences are:

- EDE is older, Projectile appears recently.
- EDE manages project files to integrate with specific build system
  and generate corresponding build file (such as Makefile; these
  features are not covered in this guide). Projectile provides generic
  file management operations such as quickly jump to file/directory in
  project, list buffers that belong to current project...
- EDE is part of CEDET suite; it is geared toward Semantic. For
  example, we used EDE to tell Semantic where to retrieve correct
  include paths for current project to perform smart completion in
  previous section. Projectile provides a generic interface for
  managing your project under a VCS or some supported build system.
- Projectile is easier to learn than EDE.

Both have some overlapping in features, such as Projectile provides
basic tag navigation in project, but in general they support each
other. For our basic usage, we use EDE for smart completion as in
previous section and Projectile to navigate our project
effortlessly

By default, =git=, =mercurial=, =darcs= and =bazaar= are considered
projects. So are =lein=, =maven=, =sbt=, =scons=, =rebar= and
=bundler=. If you want to mark a folder manually as a project just
create an empty =.projectile= file in it: 

By default, prefix key of Projectile is *C-c p*. Some notable
features:

- Jump to any file in the project: *C-c p f*.
- Jump to any directory in the project: *C-c p d*.
- List buffers local to current project: *C-c p b*.
- Jump to recently visited files in project: *C-c p e*.
- Grep in project: *C-c p g s*
- Multi-occur in project buffers: *C-c p o*.
- Simple refactoring with text replace in current project: *C-c p r*.
- Switch visited projects (visited once an Projectile remembers): *C-c p p*.

Useful commands for working with C/C++ projects:

- Run compilation command at project root: *C-c p c*. By default,
  Projectile prompts the =make= command.
- Switch between =.h= and =.c= or =.cpp=: *C-c p a*. If the filename -
  without file extension - of current editing buffer is part of other
  files, those files are listed as well. If there is only one file
  with the same name but different extension, switch immediately.

There are more. You can see all the commands [[https://github.com/bbatsov/projectile#interactive-commands][here]]. Or, simply run *C-c
p C-h* for a list of commands with *C-c p* prefix.

* Source code information
:PROPERTIES:
:ID:       7401e60b-1f91-4697-814c-1e72f395dfdd
:END:
** Command: =global-semantic-idle-summary-mode=
:PROPERTIES:
:ID:       8d06ed59-5a1a-49eb-8ea6-d3411c35b0fe
:END:
This mode, when enabled, displays function interface in the
minibuffer:

[[file:static/func_args.jpg][file:static/func_args.jpg]]

It works well for C but not C++, since C++ can overload function and
=semantic-idle-summary-mode= can only display one interface at a
time. Since this mode is part of Semantic, it also relies on
SemanticDB that is created from parsing source files.

Setup:

#+begin_src emacs-lisp
  (global-semantic-idle-summary-mode 1)
#+end_src

** Command: =global-semantic-stickyfunc-mode=
:PROPERTIES:
:ID:       50dc542d-dca8-425d-9646-083ce3ca8ae8
:END:
When enable, this mode shows the function point is currently in at the
first line of the current buffer. This is useful when you have a very
long function that spreads more than a screen, and you don't have to
scroll up to read the function name and then scroll down to original
position.

[[file:static/c-ide/semantic-sticky-func.gif][file:static/c-ide/semantic-sticky-func.gif]]

Setup:

#+begin_src emacs-lisp
  (global-semantic-stickyfunc-mode 1)
#+end_src

** Using =ggtags= + =eldoc=
:PROPERTIES:
:ID:       81db4e8e-f913-4b5c-87e4-74d90e80aaa9
:END:
You can also use =ggtags= for displaying function interface at point
in minibuffer:

#+begin_src emacs-lisp
  (setq-local eldoc-documentation-function #'ggtags-eldoc-function)
#+end_src

However, it won't have syntax highlighting.

* Source code editing
:PROPERTIES:
:ID:       0fa2afe0-728c-49f6-86f1-7769cebc5de0
:END:
** Folding
:PROPERTIES:
:ID:       48b6ad5f-24e2-41c3-9a44-c1decdde6910
:END:
Emacs has a minor mode called =hs-minor-mode= that allows users to
fold and hide blocks of text. Blocks are defined by regular
expressions which match the start and end of a text region. For
example, anything in between ={= and =}= is a block. The regular
expressions are defined in =hs-special-modes-alist=.

Setup for C/C++:

#+begin_src emacs-lisp
  (add-hook 'c-mode-common-hook   'hs-minor-mode)
#+end_src

Default key bindings:

| Key           | Binding                                    |
|---------------+--------------------------------------------|
| *C-c @ C-c*   | Command: =hs-toggle-hiding=                |
|               | Toggle hiding/showing of a block           |
|---------------+--------------------------------------------|
| *C-c @ C-h*   | Command: =hs-hide-block=                   |
|               | Select current block at point and hide it  |
|---------------+--------------------------------------------|
| *C-c @ C-l*   | Command: =hs-hide-level=                   |
|               | Hide all block with indentation levels     |
|               | below this block                           |
|---------------+--------------------------------------------|
| *C-c @ C-s*   | Command: =hs-show-block=                   |
|               | Select current block at point and show it. |
|---------------+--------------------------------------------|
| *C-c @ C-M-h* | Command: =hs-hide-all=                     |
|               | Hide all top level blocks, displaying      |
|               | only first and last lines.                 |
|---------------+--------------------------------------------|
| *C-c @ C-M-s* | Command: =hs-show-all=                     |
|               | Show everything                            |
|---------------+--------------------------------------------|

Demo:

- Command: =hs-toggle-hiding=

[[file:static/c-ide/hs-toggle-hiding.gif][file:static/c-ide/hs-toggle-hiding.gif]]

** Narrowing
:PROPERTIES:
:ID:       000644fa-84e8-42a2-b780-6ff1b0c84a5a
:END:
Narrowing means making only a text portion in current buffer
visible. Narrowing is useful when you want to perform text editing on
a small part of the buffer without affecting the others. For example,
you want to delete all =printf= statements in current functions, using
=flush-lines= command. But if you do so, you will also delete =printf=
outside the current function, which is undesirable. By narrowing, you
can safely remove all those =printf= and be certain that nothing else
is changed accidentally.

Default key bindings:

| Key       | Binding                                    |
|-----------+--------------------------------------------|
| *C-x n d* | Command: =narrow-to-defun=                 |
|           | Narrow buffer to current function at point |
|-----------+--------------------------------------------|
| *C-x n r* | Command: =narrow-to-region=                |
| *C-x n n* | Narrow buffer to active region             |
|-----------+--------------------------------------------|
| *C-x n w* | Command: =widen=                           |
|           | Widen buffer                               |
|-----------+--------------------------------------------|

** Identation
:PROPERTIES:
:ID:       2c98c4cb-0db4-4f27-9b39-d5f972cbe51a
:END:
*** Setup default C style
:PROPERTIES:
:ID:       6dd8b948-f101-4a7c-8fd8-9b836474df17
:END:
Emacs offers some popular C coding styles. Select the one suitable for
you:

#+begin_src emacs-lisp
    ;; Available C style:
    ;; “gnu”: The default style for GNU projects
    ;; “k&r”: What Kernighan and Ritchie, the authors of C used in their book
    ;; “bsd”: What BSD developers use, aka “Allman style” after Eric Allman.
    ;; “whitesmith”: Popularized by the examples that came with Whitesmiths C, an early commercial C compiler.
    ;; “stroustrup”: What Stroustrup, the author of C++ used in his book
    ;; “ellemtel”: Popular C++ coding standards as defined by “Programming in C++, Rules and Recommendations,” Erik Nyquist and Mats Henricson, Ellemtel
    ;; “linux”: What the Linux developers use for kernel development
    ;; “python”: What Python developers use for extension modules
    ;; “java”: The default style for java-mode (see below)
    ;; “user”: When you want to define your own style
    (setq
     c-default-style "linux" ;; set style to "linux"
     )
#+end_src

*** Setup indentation
:PROPERTIES:
:ID:       394da0e4-4995-4583-9b67-2611f3352d3b
:END:
By default, Emacs won't indent when press *RET* because the command
bound to *RET* is newline. You can enable automatic indentation by
binding *RET* to =newline-and-indent=.

#+begin_src emacs-lisp
    (global-set-key (kbd "RET") 'newline-and-indent)  ; automatically indent when press RET
#+end_src

When working with source code, we must pay attention to trailng
whitespace. It is always useful to view whitespace in current buffer
before committing your code.

#+begin_src emacs-lisp
  ;; activate whitespace-mode to view all whitespace characters
  (global-set-key (kbd "C-c w") 'whitespace-mode)

  ;; show unncessary whitespace that can mess up your diff
  (add-hook 'prog-mode-hook (lambda () (interactive) (setq show-trailing-whitespace 1)))

  ;; use space to indent by default
  (setq-default indent-tabs-mode nil)

  ;; set appearance of a tab that is represented by 4 spaces
  (setq-default tab-width 4)
#+end_src

To clean up trailing whitespace, you can also run =whitespace-cleanup=
command.

To convert between *TAB* and *space*, you also have two commands:
=tabify= to turn an active region to use *TAB* for indentation, and
=untabify= to turn an active region to use *space* for indentation.

*** Package: =clean-aindent-mode=
:PROPERTIES:
:ID:       12c0c0ee-66ea-411b-aa7c-0b437c4bc89d
:END:
When you press *RET* to create a newline and got indented by
=eletric-indent-mode=, you have appropriate whitespace for
indenting. But, if you leave the line blank and move to the next line,
the whitespace becomes useless. This package helps clean up unused
whitespace.

View this [[http://www.emacswiki.org/emacs/CleanAutoIndent][Emacswiki page]] for more details.

#+begin_src emacs-lisp
  ;; Package: clean-aindent-mode
  (require 'clean-aindent-mode)
  (add-hook 'prog-mode-hook 'clean-aindent-mode)
#+end_src

*** Package: =dtrt-indent=
:PROPERTIES:
:ID:       ce57a6b0-79c6-46c2-9fb2-3fb0cb3bd9c0
:END:
A minor mode that guesses the indentation offset originally used for
creating source code files and transparently adjusts the corresponding
settings in Emacs, making it more convenient to edit foreign files.

This package is really useful when you have to work on many different
projects (for example, your project consists of many git submodules)
that use different indentation format. One project might use *TAB*
for indentation; another project might use *space* for
indentation. Having to manually switch between *TAB* and *space* is
tiresome. We should let Emacs take care of it automatically. This
package does exactly that. However, if a project mixes *TAB* and
*space*, then the package will have a hard time to detect. But then
again, if you work on such project, it doesn't matter anyway.

Setup:

#+begin_src emacs-lisp
  ;; Package: dtrt-indent
  (require 'dtrt-indent)
  (dtrt-indent-mode 1)
#+end_src

If you use Semantic for code completion, you may one to turn off
=dtrt-indent= messages since Semantic may visit many files for
parsing, and each file entered a message from =dtrt-indent= is printed
in echo area and might become a constant annoyance.

#+begin_src emacs-lisp
  (setq dtrt-indent-verbosity 0)
#+end_src

*** Package: =ws-butler=
:PROPERTIES:
:ID:       65c42593-e1b3-4061-8ae8-276f29258d01
:END:
=ws-butler= helps managing whitespace on every line of code written or
edited, in an unobtrusive, help you write clean code without noisy
whitespace effortlessly. That is:

- Only lines touched get trimmed. If the white space at end of buffer
  is changed, then blank lines at the end of buffer are truncated
  respecting require-final-newline.

- Trimming only happens when saving.

With =clean-aindent-mode= and =dtrt-indent= and =ws-butler=, you
could totally forget about whitespace. If you are careful, turn on
=whitespace-mode= (bound to =C-c w= above) and check for whitespace
before committing.

Setup:

#+begin_src emacs-lisp
    ;; Package: ws-butler
  (require 'ws-butler)
  (add-hook 'c-mode-common-hook 'ws-butler-mode)
#+end_src

** Code template using =yasnippet=
:PROPERTIES:
:ID:       3952aed5-31ed-4715-a892-9f55056fe98d
:END:
YASnippet is a template system for Emacs. It allows you to type an
abbreviation and automatically expand it into function
templates. Bundled language templates include: C, C++, C#, Perl,
Python, Ruby, SQL, LaTeX, HTML, CSS and more. The snippet syntax is
inspired from TextMate's syntax, you can even import most TextMate
templates to YASnippet.

Setup:

#+begin_src emacs-lisp
  ;; Package: yasnippet
  (require 'yasnippet)
  (yas-global-mode 1)
#+end_src

_Usage_:

In major modes where *yasnippet* has snippets available,
typing a certain keyword and *TAB* insert a predefined snippet. For
example, in a C buffer, if you type =for= and *TAB*, it expands to:

#+begin_src c
  for (i = 0; i < N; i++) {
      ...point will be here....
  }
#+end_src

You can view supported snippets [[https://github.com/AndreaCrotti/yasnippet-snippets/tree/master][here]].

** Package: =smartparens=
:PROPERTIES:
:ID:       62b4b86b-222f-4915-834e-b3d79b73f9f0
:END:
=smartparens= is a minor mode that provides many features for
manipulating pairs. Pair can be simple as parentheses or brackets, or
can be programming tokens such as =if= ... =fi= or =if= ... =end= in
many languages. The most basic and essential feature is automatic
closing of a pair when user inserts an opening one.

#+begin_src emacs-lisp
    ;; Package: smartparens
  (require 'smartparens-config)
  (show-smartparens-global-mode +1)
  (smartparens-global-mode 1)
#+end_src

For complete documentation, please refer to [[https://github.com/Fuco1/smartparens/wiki#information-for-new-users][Smartparens manual]].

* Compilation Support
:PROPERTIES:
:ID:       28a612e9-d3f2-47be-acbb-91aeb9b32466
:END:
 Compilation mode turns each error message in the buffer into a
 hyperlink. You can click on each error, or execute a key binding like
 *RET* to jump to the location of that error.

 The following key bindings are available:

| Key     | Description                                                                     |
|---------+---------------------------------------------------------------------------------|
| *C-o*   | Display matched location, but *do not* switch point to matched buffer           |
|---------+---------------------------------------------------------------------------------|
| *M-n*   | Move to next error message, but *do not* visit error location                   |
|---------+---------------------------------------------------------------------------------|
| *M-p*   | Move to next previous message, but *do not* visit error location                |
|---------+---------------------------------------------------------------------------------|
| *M-g n* | Move to next error message, visit error location                                |
|---------+---------------------------------------------------------------------------------|
| *M-g p* | Move to previous error message, visit error location                            |
|---------+---------------------------------------------------------------------------------|
| *RET*   | Visit location of error at poiint                                               |
|---------+---------------------------------------------------------------------------------|
| *M-{*   | Move point to the next error message or match occurring in a different file     |
|---------+---------------------------------------------------------------------------------|
| *M-}*   | Move point to the previous error message or match occurring in a different file |
|---------+---------------------------------------------------------------------------------|
| *q*     | Quit =*compilation*= buffer                                                     |
|---------+---------------------------------------------------------------------------------|

I usually execute the same compilation command many times. It's more
convenient if Emacs doesn't ask us to confirm every time we re-execute
a command:

#+begin_src emacs-lisp
  (global-set-key (kbd "<f5>") (lambda ()
                                 (interactive)
                                 (setq-local compilation-read-command nil)
                                 (call-interactively 'compile)))
#+end_src

If you want to enter a new command, add prefix argument before
pressing =<f5>=.

Demo:

[[file:static/c-ide/compilation-mode.gif][file:static/c-ide/compilation-mode.gif]]

As you can see, output in =*compilation*= buffer looks much better
than in plain terminal with colors and you can also interact with it.

You can also run other shell commands in here, not just compilation
commands. A really cool thing with =compilation-mode= is that it is
asynchronous. That is, if your source files contain errors, you don't
have to wait for the whole compilation process to finish. You can
examine the errors right away in the =*compilation*= buffer, while the
compilation process keeps going.

*TIP*: It is useful to open a Dired buffer of the project root and
store a window configuration that contains it into a register, so you
can always jump back to project root any where, any time and run
compilation command. If you do not use know how to use registers to
store window configurations, read it [[file:emacs-tutor.org::*Registers][here]].

* Debugging
:PROPERTIES:
:ID:       a13b3e48-d73c-4fc4-97c3-b9f1d5814e63
:END:
** With GDB Many Windows
:PROPERTIES:
:ID:       57c853c1-60f7-4ec7-adc5-9eee095d302e
:END:

Emacs has built-in frontend support for GDB that provides IDE-like
interface. It has a layout like this:

[[file:static/c-ide/gdb-many-windows.gif][file:static/c-ide/gdb-many-windows.gif]]

Stock Emacs doesn't enable this layout by default. You have to
tell Emacs to always use =gdb-many-windows=:

#+begin_src emacs-lisp
  (setq
   ;; use gdb-many-windows by default
   gdb-many-windows t

   ;; Non-nil means display source file containing the main routine at startup
   gdb-show-main t
   )
#+end_src

Now, find a binary built for debugging, and start GDB by =M-x
gdb=. Emacs prompts asking you how to run =gdb=. By default, the
prompt looks like this:

[[file:static/c-ide/gdb-prompt.gif][file:static/c-ide/gdb-prompt.gif]]

To use =gdb-many-windows=, you must always supply the *-i=mi* argument
to gdb, otherwise =gdb-many-windows= won't work. By default, as you've
seen the layout of =gdb-many-windows= above, you have the following
buffers visible on your screen (ignore the first row):

|                           |                                     |
|---------------------------+-------------------------------------|
| 1. GUD interaction buffer | 2. Locals/Registers buffer          |
|---------------------------+-------------------------------------|
| 3. Primary Source buffer  | 4. I/O buffer for debugging program |
|---------------------------+-------------------------------------|
| 5. Stack buffer           | 6. Breakpoints/Threads buffer       |
|---------------------------+-------------------------------------|

Each cell coressponds to the following commands:

- =gdb-display-gdb-buffer= *(Cell 1)*: This is where you enter =gdb=
  commands, the same as in terminal. When you kill this buffer, other
  GDb buffers are also killed and debugging session is terminated.

- =gdb-display-locals-buffer= *(Cell 2)*: display local variables and
  its values in current stack frame. Please refer to [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Source-Buffers.html#Source-Buffers][GNU Manual -
  Other GDB Buffers]] for usage of the buffer.

- =gdb-display-registers-buffer= *(Cell 2)*: registers values are
  displayed here. Please refer to [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Source-Buffers.html#Source-Buffers][GNU Manual - Other GDB Buffers]] for
  usage of the buffer.

- Your source buffer *(Cell 3)*: Your source code for stepping through
  out the debugging session. Please refer to [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Source-Buffers.html#Source-Buffers][GNU Manual - Source
  Buffers]] for usage of the buffer.

- =gdb-display-io-buffer= *(Cell 4)*: This is where your program
  displays output and accepts input. In stock GDB (Command Line
  Interface), you enter input whenever a program asks for one under
  GDB prompt. Using =gdb-many-windows=, *you must enter program input
  here*.

- =gdb-display-stack-buffer= *(Cell 5)*: Display function call
  stack. Please refer to [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Stack-Buffer.html#Stack-Buffer][GNU Manual - Stack buffer]] for usage.

- =gdb-display-breakpoints-buffer= *(Cell 6)*: Display a list of
  breakpoints. Please refere to [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Breakpoints-Buffer.html#Breakpoints-Buffer][GNU Manual - Breakpoints Buffer]] for
  usage of the buffer.

- =gdb-display-threads-buffer= (Cell 6): Display running threads in
  your programs. Please refer to [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Threads-Buffer.html#Threads-Buffer][GNU Manual - Threads Buffer]] and
  [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Multithreaded-Debugging.html#Multithreaded-Debugging][Multithreaded Debugging]] for usage of the buffer. 

There are two useful commands that are not visible in
=gdb-many-windows=:

- =gdb-display-disassembly-buffer=: displays the current frame as
  assembly code.
- =gdb-display-memory-buffer=: displays a portion of program memory.

There are another variants of the above buffers, with =gdb-frame=
prefix instead of =gdb-display=. When you run commands with
=gdb-frame= prefix, the buffers are opened in a new frame instead of
occupying an existing window. This is useful when you have 2 monitors,
one is for the standard =gdb-many-windows= layout and another one is
for displaying disassembly buffer and memory buffer in a separate
frame.

** With Grand Unified Debugger - GUD
:PROPERTIES:
:ID:       79a0ad5b-3978-48f2-9bcc-f961af81bb36
:END:
The *Grand Unified Debugger*, or GUD for short, is an Emacs major mode
for debugging. It works on top of command line debuggers. GUD handles
interaction with gdb, dbx, xdb, sdb, perldb, jdb, and pdb, by
default. Emacs provides unified key bindings for those debuggers. We
only concern about GDB in this guide.

GUD works by sending text commands to a debugger subprocess, and
record its output. As you debug the program, Emacs displays relevant
source files with an arrow in the left fringe indicating the current
execution line. GUD is simple and stable. When starting GUD, you only
have a GDB command buffer and your source file. If you like
simplicity, you can use GUD. However, you can still use other
=gdb-display-= or =gdb-frame-= variants listed in previous section
when needed.

[[file:static/c-ide/gud.gif][file:static/c-ide/gud.gif]]

As you can see, the default Emacs interface also includes a menu for
regular debugging operations, such as Stop, Run, Continue, Next Line,
Up/Down Stack...

Refer to a list of commands supported by GUD at [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Commands-of-GUD.html#Commands-of-GUD][GNU Emacs Manual -
Commands of GUD]]. Note that these key bindings not only work with GDB,
but any debuggers supported by GUD, since it's a *Grand Unified
Debugger*.

There's an Emacs packages that offers support for more debuggers:
[[https://github.com/rocky/emacs-dbgr][emacs-dbgr]]. Here is [[https://github.com/rocky/emacs-dbgr/wiki/Debuggers-Supported][the list of supported debuggers]]. If you have to
work with many languages, use *GUD*.
